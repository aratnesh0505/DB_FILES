exec DBMS_SCHEDULER.STOP_JOB(job_name =>'GBS_101430',force => TRUE);

SELECT job_name FROM dba_scheduler_running_jobs WHERE job_name like '%GBS%';

select * from dba_scheduler_running_jobs;


if any packages invalid related to APEX:
============================================
cd  /u01/app/oracle/product/19.0.0.0/dbhome_1/apex/
sqlplus /nolog

SQL> conn sys as sysdba
Enter password:
Connected.

SQL> @apexins.sql SYSAUX SYSAUX TEMP /i/


***************************************************************** RESTORE TABLE **********************************************************************************

[oracle@prod-db11 restore]$ cat CS-5627_EXT_restore.cmd

run {
RECOVER TABLE ADORB.ORDER_BILLING_DETAILS_ALL of pluggable database EXT
UNTIL TIME "to_date('07/06/2023 17:00:00','mm/dd/yyyy hh24:mi:ss')"
AUXILIARY DESTINATION '+RECO'
DATAPUMP DESTINATION '/u01/app/oracle/Prod_test_refresh/restore'
DUMP FILE 'EXT_PROD_tables_restore.dmp'
NOTABLEIMPORT;
}

[oracle@prod-db11 restore]$ cat CS-5627_EXT_restore.sh
rman target /  msglog /u01/app/oracle/Prod_test_refresh/restore/CS-5627_rman_bkup.log cmdfile=/u01/app/oracle/Prod_test_refresh/restore/CS-5627_EXT_restore.cmd

[oracle@prod-db11 restore]$ cat cmmands_used
create table ADORB.ORDER_BDA_before_restore as select * from ADORB.ORDER_BILLING_DETAILS_ALL;

 nohup ./CS-5627_EXT_restore.sh &

 nohup impdp "EXT_adm/EXTpa55@EXT" tables=ADORB.ORDER_BILLING_DETAILS_ALL remap_table=ADORB.ORDER_BILLING_DETAILS_ALL:OBDA_06JUL23 directory=EXP_EXT_DIR DUMPFILE=EXT_PROD_tables_restore.dmp LOGFILE=CS-5627_EXT_OBDA_restore.log  &

[oracle@prod-db11 restore]$ pwd
/u01/app/oracle/Prod_test_refresh/restore
[oracle@prod-db11 restore]$


BACKUP ARCHIVELOG ALL DELETE INPUT;

******************************************************************* HEAVY EXTRACT *********************************************************************************
[oracle@prod-db11 scripts]$ cat CS-5875_ACI_PROD_EXTRACT.sh
#!/bin/bash

sqlplus -S / as sysdba << EOF

alter session set container= ACI;
alter session set current_schema = adorb;
set markup csv on
set pages 0
alter session  set nls_date_format  ='DD-MON-YYYY';
spool /tmp/CS-5875_ACI_PROD_EXTRACT.csv
@/home/oracle/DBA/scripts/CS-5875_ACI_PROD_EXTRACT.sql
spool off
exit;
EOF

[oracle@prod-db11 scripts]$


######   administer key management create  auto_login keystore from keystore identified by WelcomE#_1234;  ########################

select p.name,w.*  from gv$encryption_wallet w, v$pdbs p where w.con_id=p.con_id and inst_id=2;

set lines 200 pages 9999
col wrl_parameter for a45
col wrl_type for a10
col status for a10
col wallet_type for a15
select * from gv$encryption_wallet;




SQL> CREATE SEQUENCE  "CUSTOM_HOOK"."HTZ_RESRENT_LINES_S"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;



========================================================================================================

split -l 1000000 CS_7600_LGT_PROD_ACCOUNTING_SEP23.csv CS_7600_LGT_PROD_ACCOUNTING_13SEP23.csv
mv

zip CS-7453_EXT_PROD_Query1_09OCT23.csv.zip CS-7453_EXT_PROD_Query1_09OCT23_part?.csv



while true ; do  ls -ltrh CS-17883_LGT_Query_151024.csv; sleep 60; done



exec DBMS_SCHEDULER.STOP_JOB(job_name =>'GBS_582269',force => TRUE);
===========================================================================================================
select max(SOURCE_ID) from ADORB.INTG_SOURCES_CONFIG  ;
SELECT ADORB.CORE_INTEGRATION_SERVICES_S.NEXTVAl from dual;
select max(CORE_CONCURRENT_PARAMETER_ID) from ADORB.CORE_CONCURRENT_PARAMETERS;
SELECT ADORB.CORE_CONCURRENT_PARAMETERS_SEQ.NEXTVAl from dual;

ALTER SEQUENCE CORE_CONCURRENT_PROGRAM_SEQ INCREMENT BY 220;

SELECT CORE_CONCURRENT_PROGRAM_SEQ.nextval FROM dual;

ALTER SEQUENCE CORE_CONCURRENT_PARAMETERS_SEQ INCREMENT BY 90;

select max(CORE_CONCURRENT_PARAMETER_ID) from ADORB.CORE_CONCURRENT_PARAMETERS;


SELECT CORE_PER_S.nextVal FROM dual;

ALTER SEQUENCE CORE_PER_S INCREMENT BY 270;

ALTER SEQUENCE CORE_PER_S INCREMENT BY 1;
=============================================================================================================
select user_id, machine from DBA_HIST_ACTIVE_SESS_HISTORY where machine like 'DESKTOP%' and user_id=122;

CREATE INDEX order_lines_all_idx001 ON order_lines_all(order_id,TRACKING_OPTIONS,line_type);
CREATE INDEX order_lines_all_idx0001 ON order_lines_all(line_type);



#!/bin/bash

sqlplus -S / as sysdba << EOF

alter session set container= TEXPPT4;
alter session set current_schema = adorb;
spool CS-6727_provisioning.sql
set time on
set timing on
set echo on

spool off
exit;
EOF



select
owner as "Schema"
, segment_name as "Object Name"
, segment_type as "Object Type"
, round(bytes/1024/1024/1024,2) as "Object Size (Gb)"
, tablespace_name as "Tablespace"
from dba_segments
where owner='ADORB';





update adorb.core_client_token set ACCESS_TIMEOUT='31-DEC-30 12.19.40.000000 AM', REFRESH_TIMEOUT='31-DEC-30 12.19.40.000000 AM';

SELECT OBJECT_NAME, OBJECT_TYPE, owner FROM all_objects WHERE object_type in ('TABLE','PACKAGE','PACKAGE BODY','VIEW','FUNCTION','TRIGGER') and owner in ('ADORB','CUSTOM_HOOK') AND status = 'INVALID';



====================================
[aratnesh@hertz-testdb CS_12953]$ cat CS_12953_Assetenrich_data_HTZUAT1.sh
#!/bin/bash

sqlplus -S / as sysdba << EOF

alter session set container=HTZUAT1;
alter session set current_schema = CUSTOM_HOOK;
set pages 0
spool /tmp/CS_12953/CS_12953_Assetenrich_data_HTZUAT1.csv
Prompt " start Assetenrich_data_1.sql"
@/tmp/CS_12953/Assetenrich_data_1.sql

Prompt " start Assetenrich_data_2.sql"
@/tmp/CS_12953/Assetenrich_data_2.sql

Prompt " start Assetenrich_data_3.sql"
@/tmp/CS_12953/Assetenrich_data_3.sql



spool off
exit;
EOF



select count(*) machine,con_id,status from gv$session where machine like 'ms-bulk-illumio%' group by con_id,status;

 
SELECT COUNT(*) AS (SELECT USERNAME,MACHINE,CON_ID,STATUS from gv$session vs, gv$process vp WHERE and vs.con_id = vs.con_id 
  and vs.machine like '%kafka%'     AND
        vs.status = 'INACTIVE'
--and vp.SPID=14484
--and vs.SID=75
    AND
        vs.username IS NOT NULL
    AND
        vs.username != 'SYS'
ORDER BY
    vs.username,
    vs.machine,
    vs.osuser,
    vs.con_id
=========================================   
SELECT 'ALTER SYSTEM KILL SESSION '''||sid||','||serial#||''' IMMEDIATE;' FROM gv$session where machine like 'kafka%';

SELECT 'ALTER SYSTEM KILL SESSION '''||sid||','||serial#||''' IMMEDIATE;' FROM gv$session where status like 'INACTIVE%' and machine like '%ms%';

SELECT 'ALTER SYSTEM KILL SESSION '''||sid||','||serial#||''' IMMEDIATE;' FROM gv$session where status like 'ACTIVE' and machine like 'ms-settings-deviris%';

select count(*) machine,con_id,status from gv$session where status like 'ACTIVE%' group by con_id,status; 


select count(*) machine,con_id,status from gv$session where machine like 'ms%' group by con_id,status; 
                   
SET LINES 300 PAGES 1000
COL sid FOR 99999
COL spid FOR a6
COL osuser FOR a12
COL machine FOR a30
COL program FOR a16
COL username FOR a12
COL con_id FOR 999
COL inst_id FOR 9999999
COL logon_time FOR a20

SELECT 
    vs.username,
    TO_CHAR(
        vs.logon_time,
        'DD-MM-YY HH24:MI:SS'
    ) logon_time,
--ROUND(vp.pga_used_mem / (1024 * 1024),2) PGA_MB_USED,
--    vp.spid,
--   vs.sid,
--    vs.serial#,
--    vs.osuser,
    vs.machine,
--   vs.program,
    vs.con_id,
--    vs.inst_id,
    vs.status
FROM
    gv$session vs,
    gv$process vp
WHERE
        vs.paddr = vp.addr
--and vs.USERNAME = 'ADORB'
--and vs.USERNAME = 'CUSTOM_HOOK'
--and vs.USERNAME = 'CUSTOM_RESRENT'
--and vs.USERNAME = 'C##RECVUE_RW'
  and vs.con_id = vs.con_id
--  and vs.machine like '%kafka%'
and vs.status = 'ACTIVE'
--and vp.SPID=14484
--and vs.SID=75
    AND
        vs.username IS NOT NULL
    AND
        vs.username != 'SYS'
ORDER BY
    vs.username,
    vs.machine,
    vs.osuser,
    vs.con_id
/


SET PAGESIZE 51
SET LINESIZE 333
   
COLUMN INST_ID FORMAT 9
COLUMN SCHEMANAME FORMAT A11
COLUMN LOCKWAIT FORMAT A9
COLUMN PROGRAM FORMAT A27
COLUMN SID FORMAT 9999
COLUMN SERIAL# FORMAT 99999
COLUMN SPID FORMAT A5
COLUMN LOGON_TIME FORMAT A21
COLUMN STATUS FORMAT A11
COLUMN MODULE FORMAT A21
COLUMN MACHINE FORMAT A21
COLUMN  LAST_CALL_ET FORMAT 99999999
  
SELECT S.SCHEMANAME , S.INST_ID, S.SID, S.SERIAL#, P.SPID, S.LOCKWAIT, S.STATUS, S.CON_ID, S.MODULE, S.MACHINE, S.PROGRAM, TO_CHAR(S.LOGON_TIME,'DD-MON-YYYY HH24:MI:SS') AS LOGON_TIME, S.LAST_CALL_ET
FROM   GV$SESSION S, GV$PROCESS P
WHERE  S.PADDR = P.ADDR AND S.INST_ID = P.INST_ID ORDER BY S.SCHEMANAME, S.OSUSER, S.INST_ID, S.STATUS = 'ACTIVE';


===============================================================================
SELECT username, account_status, created, lock_date,profile expiry_date FROM dba_users where username like '%CUS%' and account_status != 'OPEN';


select dbms_metadata.get_ddl('USER','USER_NAME')  from dual;

Get the DDL for the User present in the Oracle database
Following is the script will provide you all the grants, profile , permission, tablespace quote of user:
Script:

set long 20000
set longchunksize 20000
set pagesize 0
set linesize 1000
set trimspool on
set column ddl format a1000
set feedback off
set verify off
--Add a semicolon at the end of each statement
execute dbms_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM,'SQLTERMINATOR',true);
--Generate the DDL for User you enter
select dbms_metadata.get_ddl('USER', u.username) AS ddl
from dba_users u
where u.username = '&&v_username'
union all
select dbms_metadata.get_granted_ddl('TABLESPACE_QUOTA', tq.username) AS ddl
from dba_ts_quotas tq
where tq.username = '&&v_username' and rownum = 1
union all
select dbms_metadata.get_granted_ddl('ROLE_GRANT', rp.grantee) AS ddl
from dba_role_privs rp
where rp.grantee = '&&v_username'
and rownum = 1
union all
select dbms_metadata.get_granted_ddl('SYSTEM_GRANT', sp.grantee) AS ddl
from dba_sys_privs sp
where sp.grantee = '&&v_username'
and rownum = 1
union all
select dbms_metadata.get_granted_ddl('OBJECT_GRANT', tp.grantee) AS ddl
from dba_tab_privs tp
where tp.grantee = '&&v_username'
and rownum = 1
union all
select dbms_metadata.get_granted_ddl('DEFAULT_ROLE', rp.grantee) AS ddl
from dba_role_privs rp
where rp.grantee = '&&v_username'
and rp.default_role = 'YES'
and rownum = 1
union all
select to_clob('/* Start profile creation script in case they are missing') AS ddl
from dba_users u
where u.username = '&&v_username'
and u.profile='DEFAULT'
and rownum = 1
union all
select dbms_metadata.get_ddl('PROFILE', u.profile) AS ddl
from dba_users u
where u.username = '&&v_username'
and u.profile='DEFAULT'
union all
select to_clob('End profile creation script */') AS ddl
from dba_users u
where u.username = '&&v_username'
and u.profile='DEFAULT'
and rownum = 1
/


======================================================  TABLESPACE  ===============================================================================================
SELECT 'ALTER DATABASE DATAFILE ''' || file_name || ''' RESIZE 5G;' AS resize_query FROM dba_data_files WHERE tablespace_name = 'USERS'; 

alter tablespace USERS add datafile size 20G autoextend on;


ALTER TABLESPACE UNDOTBS1 ADD DATAFILE size 5G AUTOEXTEND ON;

ALTER TABLESPACE TEMP ADD TEMPFILE SIZE 10G AUTOEXTEND ON;

SELECT DECODE(r, 1, tablespace_name, null) tablespace_name, file_name
FROM (select tablespace_name, file_name, rank() over (partition by tablespace_name
        order by tablespace_name, file_name) r
        from dba_data_files
        order by tablespace_name, file_name
);

select file_name, bytes/1024/1024,STATUS,TABLESPACE_NAME,AUTOEXTENSIBLE,ONLINE_STATUS from dba_temp_files where tablespace_name='TEMP';


select file_name, bytes/1024/1024,STATUS,TABLESPACE_NAME,AUTOEXTENSIBLE,ONLINE_STATUS from dba_data_files where tablespace_name='USERS';


=======================================================
ALTER SEQUENCE CORE_CONCURRENT_PARAMETERS_SEQ INCREMENT BY 435;

SELECT MESSAGE_TL_SEQ.nextval FROM dual;

ALTER SEQUENCE CORE_CONCURRENT_PARAMETERS_SEQ INCREMENT BY 1;

select max(MESSAGE_ID) from ADORB.MESSAGE_TL;


SELECT CORE_PER_S.nextVal FROM dual;

ALTER SEQUENCE CORE_PER_S INCREMENT BY 270;

ALTER SEQUENCE CORE_PER_S INCREMENT BY 1;



==================================================================
Query to check the Tenant_ID from all tables:
*************************************************
set SERVEROUTPUT ON;
DECLARE
sql_stmt VARCHAR2(1000);
lcount   NUMBER;
lquery   VARCHAR2(200);
begin
for data in( SELECT
    *
FROM
    dba_tab_columns
WHERE
    column_name LIKE 'TENANT_ID'
	AND OWNER = 'ADORB'
    AND table_name NOT IN (
        SELECT
            view_name
        FROM
            dba_views
    )
    AND table_name NOT IN (
        SELECT
            mview_name
        FROM
            dba_mviews
    )
ORDER BY
    table_name)
	loop
	lquery := 'select count(*) from '||data.owner||'.'|| data.table_name|| ' where '|| data.column_name|| '!=200';
        EXECUTE IMMEDIATE lquery INTO
            lcount;
        IF
            lcount > 0
        THEN
            dbms_output.put_line(data.column_name
             || '-----'
             || data.table_name);
        END IF;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        dbms_output.put_line(dbms_utility.format_error_backtrace || sqlerrm);
END;
/
	


Our current AMM uses the following memory
 - memory reserved  for PGA/SGA: 1600 MByte 
 - current PGA size 120 MB
 - current SGA size 904 MB
 - free memory for future PGA/SGA usage: ~ 600 MByte

For switching ASMM this can be translated into 
  SGA_MAX_SIZE             : 1400 MByte
  SGA_TARGET               : 1000 MByte
  PGA_AGGREGATE_TARGET     :  480 Mbyte

For further tuning check : V$PGA_TARGET_ADVICE